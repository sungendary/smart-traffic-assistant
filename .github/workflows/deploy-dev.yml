# ============================================================================
# Deploy to Development Workflow
# ============================================================================
# 목적: 개발 환경(develop_branch 브랜치)에 자동 배포
# 
# 주요 기능:
#   1. 코드 품질 검증 통과 확인 (린팅, 포맷팅, OpenAPI)
#   2. 핵심 기능, DB 연결, 인증 플로우 테스트 통과 확인
#   3. Docker 이미지 빌드 및 푸시
#   4. Kubernetes 매니페스트 적용
#   5. 배포 상태 확인 및 헬스 체크
#   6. 배포 롤백 (실패 시)
#
# 실행 조건:
#   - develop_branch 브랜치에 직접 push될 때 (PR merge 후)
#   - 수동 실행 (workflow_dispatch)
#
# 워크플로우:
#   1. feature 브랜치에서 작업
#   2. feature → develop_branch로 PR 생성 (수동)
#   3. PR에서 CI 검증 실행 (자동)
#   4. 리뷰 후 PR merge (수동)
#   5. develop_branch에 merge되면 → 이 워크플로우 자동 실행 (배포)
#
# 전제 조건:
#   - Kubernetes 클러스터 접근 권한 필요 (kubeconfig secret)
#   - Docker 이미지가 GHCR에 푸시되어 있어야 함
# ============================================================================

name: Deploy to Development

on:
  workflow_run:
    workflows: ["CI Integration"]  # CI 통과 후 자동 배포
    types:
      - completed
    branches:
      - develop_branch
  workflow_dispatch:  # GitHub Actions UI에서 수동 실행 가능
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'develop_branch'
      skip_ci_check:
        description: 'Skip CI check (use with caution)'
        required: false
        default: false
        type: boolean

env:
  KUBERNETES_NAMESPACE: dating-app
  IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/dating-app-api

jobs:
  # Docker 이미지 빌드 및 푸시
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/dating-app-api
          tags: |
            type=ref,event=branch
            type=sha,prefix=develop_branch-

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  # CI 통과 확인
  verify-ci:
    runs-on: ubuntu-latest
    if: |
      (github.event.workflow_run.conclusion == 'success' ||
       github.event_name == 'workflow_dispatch') &&
      !github.event.inputs.skip_ci_check
    steps:
      - name: Verify CI Integration passed
        if: github.event_name == 'workflow_run'
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "❌ CI Integration failed. Deployment cannot proceed."
            exit 1
          fi
          echo "✅ CI Integration passed. Proceeding to deployment."

  # 개발 환경 배포 작업
  deploy:
    needs: [build, verify-ci]
    if: |
      (github.event.workflow_run.conclusion == 'success' ||
       github.event_name == 'workflow_dispatch') &&
      (github.event.inputs.skip_ci_check == true || needs.verify-ci.result == 'success')
    runs-on: ubuntu-latest
    
    steps:
      # 저장소 코드 체크아웃
      - name: Checkout repository
        uses: actions/checkout@v4

      # Kubernetes 설정
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # Kubernetes 클러스터 연결
      # 실제 환경에서는 kubeconfig를 secret으로 관리해야 함
      - name: Configure Kubernetes
        run: |
          echo "Kubernetes configuration would go here"
          echo "In production, use: kubectl config set-cluster ..."
        # 실제 사용 예시:
        # run: |
        #   echo "${{ secrets.KUBECONFIG_DEV }}" | base64 -d > kubeconfig
        #   export KUBECONFIG=./kubeconfig

      # 배포할 이미지 태그 결정
      - name: Determine image tag
        id: image-tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=develop_branch-${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      # Kubernetes 매니페스트에 이미지 태그 업데이트
      - name: Update deployment manifest
        run: |
          sed -i "s|image:.*dating-app-api.*|image: ${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}|g" \
            k8s/api-deployment.yaml

      # 네임스페이스 생성 (없는 경우)
      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.KUBERNETES_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      # ConfigMap 적용
      - name: Apply ConfigMap
        run: |
          kubectl apply -f k8s/app-configmap.yaml -n ${{ env.KUBERNETES_NAMESPACE }}

      # Secret 적용 (실제 환경에서는 secret이 이미 존재해야 함)
      - name: Apply Secrets
        run: |
          if [ -f k8s/app-secrets.yaml ]; then
            kubectl apply -f k8s/app-secrets.yaml -n ${{ env.KUBERNETES_NAMESPACE }}
          else
            echo "Warning: app-secrets.yaml not found. Using existing secrets."
          fi

      # API Deployment 적용
      - name: Deploy API
        run: |
          kubectl apply -f k8s/api-deployment.yaml -n ${{ env.KUBERNETES_NAMESPACE }}

      # 배포 상태 확인
      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/dating-app-api -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=5m

      # 헬스 체크 - Pod가 Ready 상태인지 확인
      - name: Wait for pods to be ready
        run: |
          echo "Waiting for pods to be ready..."
          kubectl wait --for=condition=ready pod \
            -l app=dating-app-api \
            -n ${{ env.KUBERNETES_NAMESPACE }} \
            --timeout=300s

      # 실제 HTTP 헬스 체크
      - name: Health check via port-forward
        run: |
          echo "Performing health check..."
          # 포트포워딩을 백그라운드로 실행
          kubectl port-forward -n ${{ env.KUBERNETES_NAMESPACE }} \
            deployment/dating-app-api 8080:8000 &
          PF_PID=$!
          
          # 포트포워딩이 준비될 때까지 대기
          sleep 5
          
          # 헬스 체크 요청
          for i in {1..10}; do
            if curl -f http://localhost:8080/api/health; then
              echo "✅ Health check passed!"
              kill $PF_PID
              exit 0
            fi
            echo "Attempt $i/10: Health check failed, retrying..."
            sleep 3
          done
          
          kill $PF_PID
          echo "❌ Health check failed after 10 attempts"
          exit 1

      # 스모크 테스트 - 주요 API 엔드포인트 검증
      - name: Smoke tests
        run: |
          echo "Running smoke tests..."
          kubectl port-forward -n ${{ env.KUBERNETES_NAMESPACE }} \
            deployment/dating-app-api 8080:8000 &
          PF_PID=$!
          sleep 5
          
          # API 루트 엔드포인트 확인
          if curl -f http://localhost:8080/; then
            echo "✅ Root endpoint is accessible"
          else
            echo "❌ Root endpoint failed"
            kill $PF_PID
            exit 1
          fi
          
          # OpenAPI 문서 확인
          if curl -f http://localhost:8080/docs; then
            echo "✅ API documentation is accessible"
          else
            echo "⚠️ API documentation not accessible (may be expected)"
          fi
          
          kill $PF_PID
          echo "✅ Smoke tests passed"

      # 배포 정보 출력
      - name: Deployment info
        run: |
          echo "## Deployment Information" >> $GITHUB_STEP_SUMMARY
          echo "- Namespace: ${{ env.KUBERNETES_NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "- Image: ${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment: dating-app-api" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }} -l app=dating-app-api

