# ============================================================================
# Deploy to Production Workflow
# ============================================================================
# 목적: 프로덕션 환경(main 브랜치)에 배포 (수동 승인 필요)
# 
# 주요 기능:
#   1. 코드 품질 검증 통과 확인 (린팅, 포맷팅, OpenAPI)
#   2. 핵심 기능, DB 연결, 인증 플로우 테스트 통과 확인
#   3. 보안 검사 통과 확인
#   4. 프로덕션 배포 승인 대기
#   5. Kubernetes 매니페스트 적용
#   6. 배포 상태 확인 및 헬스 체크
#   7. 배포 롤백 (실패 시)
#
# 실행 조건:
#   - main 브랜치에 push되고 모든 CI가 통과한 후
#   - 수동 실행 (workflow_dispatch)
#
# 보안:
#   - 프로덕션 배포는 수동 승인이 필요함
#   - 환경 보호 규칙 적용 권장
# ============================================================================

name: Deploy to Production

on:
  workflow_run:
    workflows: ["CI Integration"]  # 통합 CI 워크플로우 완료 후 트리거
    types:
      - completed
    branches:
      - main
  workflow_dispatch:  # GitHub Actions UI에서 수동 실행 가능
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'
      skip_approval:
        description: 'Skip approval (use with caution)'
        required: false
        default: false
        type: boolean

env:
  KUBERNETES_NAMESPACE: dating-app-prod
  IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/dating-app-api
  PRODUCTION_URL: ""  # 실제 프로덕션 URL이 있으면 설정 (예: https://api.yourdomain.com)

jobs:
  # 프로덕션 배포 승인 대기
  # GitHub 환경 보호 규칙을 사용하여 승인 처리
  # 리포지토리 Settings > Environments > production에서 승인자 설정 필요
  approval:
    runs-on: ubuntu-latest
    if: |
      (github.event.workflow_run.conclusion == 'success' ||
       github.event_name == 'workflow_dispatch') &&
      !github.event.inputs.skip_approval
    environment:
      name: production
      url: https://api.yourdomain.com  # 실제 프로덕션 URL
    steps:
      - name: Verify CI Integration passed
        if: github.event_name == 'workflow_run'
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "❌ CI Integration failed. Deployment cannot proceed."
            exit 1
          fi
          echo "✅ CI Integration passed. Proceeding to approval."
      
      # GitHub 환경 보호 규칙을 사용하여 승인 처리
      # 리포지토리 Settings > Environments > production에서 승인자 설정 필요
      - name: Approval notification
        run: |
          echo "## Production Deployment Approval" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Actor:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pre-deployment Checklist" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] All CI checks passed" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Security scan passed" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Manual testing completed" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Rollback plan reviewed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ Waiting for approval from configured reviewers..." >> $GITHUB_STEP_SUMMARY

  # 프로덕션 배포 작업
  deploy:
    runs-on: ubuntu-latest
    needs: [approval]
    if: |
      (github.event.workflow_run.conclusion == 'success' ||
       github.event_name == 'workflow_dispatch') &&
      (github.event.inputs.skip_approval == true || needs.approval.result == 'success')
    
    environment:
      name: production
      url: https://api.yourdomain.com  # 실제 프로덕션 URL

    steps:
      # 저장소 코드 체크아웃
      - name: Checkout repository
        uses: actions/checkout@v4

      # Kubernetes 설정
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # Kubernetes 클러스터 연결
      - name: Configure Kubernetes
        run: |
          echo "Kubernetes configuration for production"
          # 실제 사용 예시 (KUBECONFIG_PROD secret이 설정되어 있어야 함):
          # if [ -n "${{ secrets.KUBECONFIG_PROD }}" ]; then
          #   echo "${{ secrets.KUBECONFIG_PROD }}" | base64 -d > kubeconfig
          #   export KUBECONFIG=./kubeconfig
          # fi

      # 배포할 이미지 태그 결정
      - name: Determine image tag
        id: image-tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=latest" >> $GITHUB_OUTPUT
          fi

      # Kubernetes 매니페스트에 이미지 태그 업데이트
      - name: Update deployment manifest
        run: |
          sed -i "s|image:.*dating-app-api.*|image: ${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}|g" \
            k8s/api-deployment.yaml
          # 프로덕션 환경에 맞게 replicas 조정 가능
          # sed -i "s|replicas:.*|replicas: 3|g" k8s/api-deployment.yaml

      # 네임스페이스 생성
      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.KUBERNETES_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      # ConfigMap 적용
      - name: Apply ConfigMap
        run: |
          kubectl apply -f k8s/app-configmap.yaml -n ${{ env.KUBERNETES_NAMESPACE }}

      # Secret 적용
      - name: Apply Secrets
        run: |
          if [ -f k8s/app-secrets.yaml ]; then
            kubectl apply -f k8s/app-secrets.yaml -n ${{ env.KUBERNETES_NAMESPACE }}
          else
            echo "Warning: app-secrets.yaml not found. Using existing secrets."
          fi

      # API Deployment 적용 (롤링 업데이트)
      - name: Deploy API
        run: |
          kubectl apply -f k8s/api-deployment.yaml -n ${{ env.KUBERNETES_NAMESPACE }}

      # 배포 상태 확인
      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/dating-app-api -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=10m

      # 헬스 체크 - Pod가 Ready 상태인지 확인
      - name: Wait for pods to be ready
        run: |
          echo "Waiting for pods to be ready..."
          kubectl wait --for=condition=ready pod \
            -l app=dating-app-api \
            -n ${{ env.KUBERNETES_NAMESPACE }} \
            --timeout=600s

      # 실제 HTTP 헬스 체크
      - name: Health check via port-forward
        run: |
          echo "Performing health check..."
          # 포트포워딩을 백그라운드로 실행
          kubectl port-forward -n ${{ env.KUBERNETES_NAMESPACE }} \
            deployment/dating-app-api 8080:8000 &
          PF_PID=$!
          
          # 포트포워딩이 준비될 때까지 대기
          sleep 10
          
          # 헬스 체크 요청
          for i in {1..15}; do
            if curl -f http://localhost:8080/api/health; then
              echo "✅ Health check passed!"
              kill $PF_PID
              exit 0
            fi
            echo "Attempt $i/15: Health check failed, retrying..."
            sleep 5
          done
          
          kill $PF_PID
          echo "❌ Health check failed after 15 attempts"
          exit 1

      # 스모크 테스트 - 주요 API 엔드포인트 검증
      - name: Smoke tests
        run: |
          echo "Running smoke tests..."
          kubectl port-forward -n ${{ env.KUBERNETES_NAMESPACE }} \
            deployment/dating-app-api 8080:8000 &
          PF_PID=$!
          sleep 10
          
          # API 루트 엔드포인트 확인
          if curl -f http://localhost:8080/; then
            echo "✅ Root endpoint is accessible"
          else
            echo "❌ Root endpoint failed"
            kill $PF_PID
            exit 1
          fi
          
          # OpenAPI 문서 확인
          if curl -f http://localhost:8080/docs; then
            echo "✅ API documentation is accessible"
          else
            echo "⚠️ API documentation not accessible (may be expected)"
          fi
          
          # 외부 URL이 설정된 경우 추가 검증
          if [ -n "${{ env.PRODUCTION_URL }}" ]; then
            echo "Testing external URL: ${{ env.PRODUCTION_URL }}"
            if curl -f ${{ env.PRODUCTION_URL }}/api/health; then
              echo "✅ External health check passed"
            else
              echo "⚠️ External health check failed (may need ingress setup)"
            fi
          fi
          
          kill $PF_PID
          echo "✅ Smoke tests passed"

      # 배포 정보 출력
      - name: Deployment info
        run: |
          echo "## Production Deployment Information" >> $GITHUB_STEP_SUMMARY
          echo "- Namespace: ${{ env.KUBERNETES_NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "- Image: ${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment: dating-app-api" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ✅ Deployed successfully" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }} -l app=dating-app-api

      # 배포 알림 (선택사항)
      - name: Deployment notification
        if: success()
        run: |
          echo "Production deployment completed successfully"
          # Slack, Discord, Email 알림 추가 가능

  # 롤백 작업 (배포 실패 시)
  rollback:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: failure()
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Rollback deployment
        run: |
          kubectl rollout undo deployment/dating-app-api -n ${{ env.KUBERNETES_NAMESPACE }}
          kubectl rollout status deployment/dating-app-api -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=5m

      - name: Rollback notification
        run: |
          echo "## ⚠️ Production Deployment Rolled Back" >> $GITHUB_STEP_SUMMARY
          echo "Deployment failed and was automatically rolled back." >> $GITHUB_STEP_SUMMARY

